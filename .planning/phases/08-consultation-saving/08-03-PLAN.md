---
phase: 08-consultation-saving
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/hooks/useSavePreference.ts
  - src/hooks/useConsultations.ts
  - src/hooks/useChat.ts
  - src/contexts/ConsultationContext.tsx
  - src/components/chat/ChatSidebar.tsx
  - src/components/chat/ConsultationList.tsx
  - src/components/chat/SavePrompt.tsx
  - src/app/chat/page.tsx
autonomous: true

must_haves:
  truths:
    - "Messages auto-save when savePreference is 'save'"
    - "Save prompt appears when starting new chat if savePreference was 'pending'"
    - "Consultation list shows saved consultations from Firestore"
    - "Clicking consultation in list loads it"
  artifacts:
    - path: "src/hooks/useSavePreference.ts"
      provides: "Hook for reading/writing save-by-default preference"
      exports: ["useSavePreference"]
    - path: "src/hooks/useConsultations.ts"
      provides: "Hook for fetching user's consultation list"
      exports: ["useConsultations"]
    - path: "src/components/chat/SavePrompt.tsx"
      provides: "Modal prompt asking to save current chat"
      exports: ["SavePrompt"]
  key_links:
    - from: "src/hooks/useChat.ts"
      to: "src/contexts/ConsultationContext.tsx"
      via: "updates messages in context"
      pattern: "updateMessages"
    - from: "src/contexts/ConsultationContext.tsx"
      to: "src/lib/firebase/consultations.ts"
      via: "debounced Firestore writes"
      pattern: "updateConsultation"
    - from: "src/components/chat/ConsultationList.tsx"
      to: "src/hooks/useConsultations.ts"
      via: "fetches consultation list"
      pattern: "useConsultations"
---

<objective>
Implement the save mechanism: auto-save with debounce, save prompt flow, and wire sidebar to real data.

Purpose: This is the core saving functionality. When savePreference='save', messages auto-save. When 'pending', user is prompted. The sidebar now shows real consultation history.

Output: Working save flow with debounced writes, save prompt dialog, and consultation list connected to Firestore.
</objective>

<execution_context>
@/Users/mad/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mad/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-consultation-saving/08-CONTEXT.md
@.planning/phases/08-consultation-saving/08-RESEARCH.md

# From Plan 01
@src/types/index.ts
@src/lib/firebase/consultations.ts
@src/contexts/ConsultationContext.tsx

# From Plan 02
@src/components/chat/ChatSidebar.tsx
@src/components/chat/ConsultationList.tsx

# Existing
@src/hooks/useChat.ts
@src/app/chat/page.tsx
@src/lib/firebase/firestore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create save preference and consultations hooks</name>
  <files>src/hooks/useSavePreference.ts, src/hooks/useConsultations.ts</files>
  <action>
1. Create useSavePreference.ts:
```typescript
// Reads/writes saveByDefault from user doc (not consultation doc)
// Default: true (save by default per CONTEXT.md)

interface UseSavePreferenceReturn {
  saveByDefault: boolean;
  isLoading: boolean;
  setSaveByDefault: (value: boolean) => Promise<void>;
}

// Use onSnapshot for real-time updates
// Store in users/{uid}.saveByDefault field
// Follow pattern from SubscriptionContext for listening
```

2. Create useConsultations.ts:
```typescript
// Fetches user's saved consultations for sidebar list

interface UseConsultationsReturn {
  consultations: ConsultationMeta[];
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
}

// Calls getUserConsultations from consultations.ts
// Returns metadata only (id, title, updatedAt, topic)
// Refresh on mount and when refetch called
```
  </action>
  <verify>`npm run build` passes</verify>
  <done>Both hooks created and exported</done>
</task>

<task type="auto">
  <name>Task 2: Wire save mechanism with debounce</name>
  <files>src/contexts/ConsultationContext.tsx, src/hooks/useChat.ts</files>
  <action>
1. Update ConsultationContext.tsx to add debounced Firestore writes:

```typescript
// Add debounce for auto-save (2 second delay)
const debouncedSave = useMemo(() =>
  debounce(async (messages: ConsultationMessage[]) => {
    if (!consultationId || !user?.uid) return;
    if (consultation?.savePreference !== 'save') return;

    await updateConsultation(user.uid, consultationId, {
      messages,
      updatedAt: new Date(),
    });
  }, 2000),
  [consultationId, user?.uid, consultation?.savePreference]
);

// Call debouncedSave when updateMessages is called
```

Use lodash.debounce or implement simple debounce. Import from lodash-es if available, or create utility.

2. Update useChat.ts to integrate with ConsultationContext:

After each message (user or assistant), call `updateMessages` on the context. The context handles debounced persistence.

Key changes:
- Import useConsultation hook
- After adding user message, call updateMessages
- After streaming completes (assistant message done), call updateMessages
- Handle the message format conversion (ChatMessage -> ConsultationMessage with timestamp)
  </action>
  <verify>Send a message, wait 2+ seconds, check Firestore console for saved data</verify>
  <done>Messages auto-save to Firestore when savePreference='save'</done>
</task>

<task type="auto">
  <name>Task 3: Create SavePrompt and wire consultation list</name>
  <files>src/components/chat/SavePrompt.tsx, src/components/chat/ConsultationList.tsx, src/components/chat/ChatSidebar.tsx, src/app/chat/page.tsx</files>
  <action>
1. Create SavePrompt.tsx - modal shown when leaving a chat that has savePreference='pending':

```typescript
interface SavePromptProps {
  isOpen: boolean;
  onSave: () => void;      // Set savePreference='save'
  onDontSave: () => void;  // Set savePreference='dont_save'
  onCancel: () => void;    // Stay in current chat
}
```

Lithuanian copy:
- Title: "Issaugoti konsultacija?"
- Body: "Ar norite issaugoti sia konsultacija?"
- Buttons: "Issaugoti" (primary), "Neissaugoti" (destructive), "Atsaukti" (ghost)

Use existing modal patterns (see DeleteAccountModal).

2. Update ConsultationList.tsx:
- Use useConsultations hook to fetch real data
- Render list items with title, relative time, topic badge
- Handle loading state with skeletons
- Handle empty state
- Call onSelect prop when item clicked

3. Update ChatSidebar.tsx:
- Pass onSelect handler that calls loadConsultation from context
- Show active consultation as selected

4. Update page.tsx:
- Show SavePrompt when user clicks "Nauja konsultacija" and current chat has pending save
- Wire handleNewConsultation to check savePreference before clearing
  </action>
  <verify>
- Open /chat, send message, click "Nauja konsultacija" - save prompt appears
- After saving, consultation appears in sidebar list
- Clicking item in list loads that consultation
</verify>
  <done>Save prompt works, consultation list shows real data from Firestore</done>
</task>

</tasks>

<verification>
- `npm run build` passes
- Auto-save: send message with saveByDefault=true, check Firestore after 2s
- Save prompt: click new consultation with unsaved chat, prompt appears
- List: saved consultations appear in sidebar
- Load: clicking consultation loads its messages into chat
</verification>

<success_criteria>
- Messages persist to Firestore with 2s debounce when savePreference='save'
- Save prompt appears when navigating away from pending chat
- Consultation list fetches and displays real data
- Selecting a consultation loads it into the chat view
</success_criteria>

<output>
After completion, create `.planning/phases/08-consultation-saving/08-03-SUMMARY.md`
</output>
