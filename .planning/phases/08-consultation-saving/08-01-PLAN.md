---
phase: 08-consultation-saving
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/firebase/consultations.ts
  - firestore.rules
  - src/contexts/ConsultationContext.tsx
autonomous: true

must_haves:
  truths:
    - "Consultation documents can be created in Firestore"
    - "Consultation documents can be read/updated/deleted by owner only"
    - "Security rules prevent cross-user access"
  artifacts:
    - path: "src/types/index.ts"
      provides: "ConsultationDocument, ConsultationMeta types"
      contains: "interface ConsultationDocument"
    - path: "src/lib/firebase/consultations.ts"
      provides: "CRUD functions for consultations subcollection"
      exports: ["createConsultation", "updateConsultation", "getConsultation", "getUserConsultations", "deleteConsultation"]
    - path: "firestore.rules"
      provides: "Security rules for consultations subcollection"
      contains: "match /consultations/{consultationId}"
    - path: "src/contexts/ConsultationContext.tsx"
      provides: "React context for current consultation state"
      exports: ["ConsultationProvider", "useConsultation"]
  key_links:
    - from: "src/lib/firebase/consultations.ts"
      to: "firebase/firestore"
      via: "Firestore SDK imports"
      pattern: "collection.*users.*consultations"
    - from: "src/contexts/ConsultationContext.tsx"
      to: "src/lib/firebase/consultations.ts"
      via: "imports CRUD functions"
      pattern: "import.*from.*consultations"
---

<objective>
Create the Firestore data layer for consultation persistence.

Purpose: Establish the foundation for saving and retrieving chat history. All subsequent plans depend on this data layer being in place.

Output: Types, CRUD functions, security rules, and a React context for managing current consultation state.
</objective>

<execution_context>
@/Users/mad/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mad/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-consultation-saving/08-CONTEXT.md
@.planning/phases/08-consultation-saving/08-RESEARCH.md

@src/types/index.ts
@src/lib/firebase/firestore.ts
@src/lib/firebase/config.ts
@src/contexts/SubscriptionContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add consultation types and Firestore CRUD</name>
  <files>src/types/index.ts, src/lib/firebase/consultations.ts</files>
  <action>
1. In src/types/index.ts, add:
```typescript
// Consultation persistence types
export interface ConsultationMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  sources?: ChatSource[];
  timestamp: Date;
}

export interface ConsultationDocument {
  id: string;
  title: string;  // LLM-generated, max 60 chars
  createdAt: Date;
  updatedAt: Date;
  status: 'active' | 'completed';
  savePreference: 'save' | 'dont_save' | 'pending';
  context: {
    userRole: string;
    companySize: string;
    topic: string;
  };
  messages: ConsultationMessage[];
}

export interface ConsultationMeta {
  id: string;
  title: string;
  updatedAt: Date;
  topic: string;
}
```

2. Create src/lib/firebase/consultations.ts with:
- `createConsultation(uid, data)` - Creates new consultation doc, returns ID
- `updateConsultation(uid, consultationId, data)` - Partial update with merge
- `getConsultation(uid, consultationId)` - Get single consultation with messages
- `getUserConsultations(uid, limit=50)` - Get list (metadata only: id, title, updatedAt, topic), ordered by updatedAt desc, filtered to savePreference='save'
- `deleteConsultation(uid, consultationId)` - Delete single consultation

Use pattern from existing firestore.ts. Handle Timestamp conversion to Date. Store in `users/{uid}/consultations/{consultationId}` subcollection.
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>Types exported from index.ts, all 5 CRUD functions exported from consultations.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add Firestore security rules for consultations</name>
  <files>firestore.rules</files>
  <action>
Add security rules for the consultations subcollection. User can only read/write their own consultations.

```javascript
match /users/{userId}/consultations/{consultationId} {
  allow read, write: if request.auth != null && request.auth.uid == userId;
}
```

Place this inside the existing `match /users/{userId}` block if one exists, or create the nested structure. Ensure the rule is placed correctly within the rules_version and service blocks.
  </action>
  <verify>Deploy rules with `firebase deploy --only firestore:rules` (or verify syntax with `firebase emulators:start --only firestore` if available)</verify>
  <done>Security rules file updated with consultations subcollection rules</done>
</task>

<task type="auto">
  <name>Task 3: Create ConsultationContext for current chat state</name>
  <files>src/contexts/ConsultationContext.tsx</files>
  <action>
Create a React context that manages the current consultation session. Follow the pattern from SubscriptionContext.tsx.

```typescript
interface ConsultationContextValue {
  consultationId: string | null;
  consultation: ConsultationDocument | null;
  isLoading: boolean;

  // Actions
  startNewConsultation: (context: { userRole: string; companySize: string; topic: string }) => Promise<string>;
  loadConsultation: (id: string) => Promise<void>;
  updateMessages: (messages: ConsultationMessage[]) => void;
  setTitle: (title: string) => void;
  setSavePreference: (pref: 'save' | 'dont_save') => void;
  clearConsultation: () => void;
}
```

Key behaviors:
- `startNewConsultation` creates a new doc in Firestore with status='active', savePreference='pending', empty messages
- `loadConsultation` fetches an existing consultation and sets it as current
- `updateMessages` is called to update local state (actual Firestore save happens via debounce in Plan 03)
- `setTitle` updates local title (Firestore update in Plan 04)
- `clearConsultation` resets state for new chat

For now, this context manages LOCAL state only. Firestore persistence will be wired in Plan 03.

Wrap with AuthContext - only create consultations for authenticated users.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>ConsultationContext created with provider and hook, exports ConsultationProvider and useConsultation</done>
</task>

</tasks>

<verification>
- `npm run build` passes
- Types are correctly exported
- CRUD functions handle Timestamp/Date conversion
- Security rules syntax is valid
- ConsultationContext follows existing context patterns
</verification>

<success_criteria>
- ConsultationDocument type exists with all fields from RESEARCH.md
- 5 CRUD functions exported from consultations.ts
- Security rules deployed or ready to deploy
- ConsultationContext provides consultation state management
</success_criteria>

<output>
After completion, create `.planning/phases/08-consultation-saving/08-01-SUMMARY.md`
</output>
