---
phase: 08-consultation-saving
plan: 04
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/lib/gemini/title.ts
  - src/contexts/ConsultationContext.tsx
  - src/components/chat/ChatInterface.tsx
  - src/hooks/useChat.ts
autonomous: true

must_haves:
  truths:
    - "Title is generated after first user+assistant exchange"
    - "Title appears in sidebar after generation"
    - "Loading a saved consultation shows its messages"
    - "User can continue a loaded consultation"
  artifacts:
    - path: "src/lib/gemini/title.ts"
      provides: "Function to generate consultation title via Gemini Flash"
      exports: ["generateConsultationTitle"]
    - path: "src/components/chat/ChatInterface.tsx"
      provides: "Chat component that can display loaded messages"
      contains: "consultation?.messages"
  key_links:
    - from: "src/contexts/ConsultationContext.tsx"
      to: "src/lib/gemini/title.ts"
      via: "calls title generation after first exchange"
      pattern: "generateConsultationTitle"
    - from: "src/components/chat/ChatInterface.tsx"
      to: "src/contexts/ConsultationContext.tsx"
      via: "reads loaded consultation messages"
      pattern: "useConsultation"
---

<objective>
Implement LLM title generation and consultation loading/continuation.

Purpose: Consultations need meaningful titles for the history list. Users need to be able to view and continue past consultations.

Output: Auto-generated Lithuanian titles, working load/continue flow for saved chats.
</objective>

<execution_context>
@/Users/mad/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mad/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-consultation-saving/08-CONTEXT.md
@.planning/phases/08-consultation-saving/08-RESEARCH.md

# From Plan 01
@src/types/index.ts
@src/lib/firebase/consultations.ts
@src/contexts/ConsultationContext.tsx

# Existing
@src/lib/gemini/index.ts
@src/components/chat/ChatInterface.tsx
@src/hooks/useChat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create title generation function</name>
  <files>src/lib/gemini/title.ts</files>
  <action>
Create a function to generate consultation titles using Gemini Flash.

```typescript
import { getGenAI } from './index';

const TITLE_PROMPT = `Sugeneruok trumpa pavadinima siai teisinei konsultacijai lietuviu kalba.
Reikalavimai:
- Maksimum 6 zodziai
- Be kabučių ar skyrybos
- Apibendrina pagrindine tema

Vartotojo klausimas: {userMessage}
Asistento atsakymo santrauka: {assistantSummary}

Pavadinimas:`;

export async function generateConsultationTitle(
  userMessage: string,
  assistantMessage: string
): Promise<string> {
  const model = getGenAI().getGenerativeModel({ model: 'gemini-2.0-flash' });

  const prompt = TITLE_PROMPT
    .replace('{userMessage}', userMessage.slice(0, 500))
    .replace('{assistantSummary}', assistantMessage.slice(0, 300));

  const result = await model.generateContent(prompt);
  const title = result.response.text().trim();

  // Clean up: remove quotes, limit length
  return title.replace(/["""'']/g, '').slice(0, 60);
}
```

Handle errors gracefully - return fallback title like "Konsultacija" if generation fails.
  </action>
  <verify>`npm run build` passes</verify>
  <done>generateConsultationTitle function exported</done>
</task>

<task type="auto">
  <name>Task 2: Trigger title generation after first exchange</name>
  <files>src/contexts/ConsultationContext.tsx</files>
  <action>
Add title generation logic to ConsultationContext:

1. After the first assistant message completes (messages.length === 2: one user, one assistant):
   - Check if title is empty or placeholder
   - If so, call generateConsultationTitle with first user message and first assistant message
   - Update consultation title in Firestore and local state

2. Implementation:
```typescript
// In effect that watches messages
useEffect(() => {
  if (!consultation || !consultationId || !user?.uid) return;
  if (consultation.title && consultation.title !== 'Nauja konsultacija') return;

  const messages = consultation.messages;
  if (messages.length < 2) return;

  const userMsg = messages.find(m => m.role === 'user');
  const assistantMsg = messages.find(m => m.role === 'assistant');
  if (!userMsg || !assistantMsg || !assistantMsg.content) return;

  // Generate title async - don't block
  generateConsultationTitle(userMsg.content, assistantMsg.content)
    .then(title => {
      setTitle(title);
      updateConsultation(user.uid, consultationId, { title });
    })
    .catch(err => {
      console.error('Title generation failed:', err);
      // Keep placeholder title
    });
}, [consultation?.messages.length]);
```

Use a ref to prevent duplicate generation attempts.
  </action>
  <verify>Send first message, wait for response, check if title updates in sidebar</verify>
  <done>Title auto-generates after first exchange, appears in sidebar</done>
</task>

<task type="auto">
  <name>Task 3: Enable loading and continuing saved consultations</name>
  <files>src/components/chat/ChatInterface.tsx, src/hooks/useChat.ts</files>
  <action>
1. Update ChatInterface.tsx to support loaded consultations:

```typescript
// Get consultation from context
const { consultation, consultationId } = useConsultation();

// Initialize messages from consultation if loading existing
useEffect(() => {
  if (consultation?.messages && consultation.messages.length > 0) {
    // Convert ConsultationMessage[] to ChatMessage[]
    const chatMessages = consultation.messages.map(m => ({
      id: m.id,
      role: m.role,
      content: m.content,
      sources: m.sources,
    }));
    // Set initial messages in useChat
    setInitialMessages(chatMessages);
  }
}, [consultationId]);
```

2. Update useChat.ts to accept initial messages:

Add `initialMessages` option or `setMessages` setter to allow ChatInterface to seed the messages array when loading a saved consultation.

```typescript
// Add to useChat options
interface UseChatOptions {
  context?: ChatContext;
  userId?: string;
  initialMessages?: Message[];
}

// In hook, seed messages if provided
useEffect(() => {
  if (options?.initialMessages && options.initialMessages.length > 0) {
    setMessages(options.initialMessages);
  }
}, [options?.initialMessages]);
```

3. Allow continuation:
- Loaded chats are NOT read-only (per RESEARCH.md recommendation)
- User can send new messages which append to the loaded messages
- New messages trigger the same save flow (debounced)
- If consultation was 'completed', change to 'active' when user sends new message
  </action>
  <verify>
- Click saved consultation in sidebar
- Chat loads with previous messages
- Send new message - appends to history
- New messages save to Firestore
</verify>
  <done>Saved consultations load and can be continued</done>
</task>

</tasks>

<verification>
- `npm run build` passes
- Title generation: after first exchange, title appears (not "Nauja konsultacija")
- Title in Lithuanian, max 6 words
- Load consultation: click in sidebar, messages appear
- Continue: send message to loaded chat, it saves
</verification>

<success_criteria>
- generateConsultationTitle produces Lithuanian titles
- Titles auto-generate after first user+assistant exchange
- Clicking consultation in list loads its messages
- User can continue loaded consultations with new messages
- Continued messages save correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-consultation-saving/08-04-SUMMARY.md`
</output>
